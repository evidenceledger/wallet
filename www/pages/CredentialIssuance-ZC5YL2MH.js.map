{
  "version": 3,
  "sources": ["../../front/src/pages/CredentialIssuance.js"],
  "sourcesContent": ["import { credentialsSave } from \"../components/db\";\r\nimport { decodeUnsafeJWT } from \"../components/jwt\";\r\nimport {\r\n   getOrCreateDidKey,\r\n   importFromJWK,\r\n   verify,\r\n   signWithJWK,\r\n   signJWT,\r\n} from \"../components/crypto\";\r\n\r\nimport { renderAnyCredentialCard } from \"../components/renderAnyCredential\";\r\n\r\n// Setup some local variables for convenience\r\nlet gotoPage = window.MHR.gotoPage;\r\nlet goHome = window.MHR.goHome;\r\nlet storage = window.MHR.storage;\r\nlet myerror = window.MHR.storage.myerror;\r\nlet mylog = window.MHR.storage.mylog;\r\n\r\n// Make all requests via the server instead of from the JavaScript client\r\nconst viaServer = \"https://wallet.mycredential.eu/serverhandler\";\r\nvar proxyIssuer = false\r\n\r\nconst PRE_AUTHORIZED_CODE_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:pre-authorized_code\";\r\n\r\nwindow.MHR.register(\r\n   \"CredentialIssuance\",\r\n   class extends window.MHR.AbstractPage {\r\n      constructor(id) {\r\n         super(id);\r\n         this.VC = \"\";\r\n         this.VCType = \"\";\r\n         this.VCStatus = \"\";\r\n      }\r\n\r\n      /**\r\n       * Handles the entry point for the LoadAndSaveQRVC page.\r\n       * Processes QR code data to load and potentially save a Verifiable Credential (VC).\r\n       *\r\n       * @param {string} qrData - The data scanned from a QR code or received as a redirection.\r\n       * @returns {Promise<void>}\r\n       */\r\n      async enter(qrData) {\r\n         debugger;\r\n         this.qrData = qrData;\r\n\r\n         mylog(`LoadAndSaveQRVC: ${qrData}`);\r\n\r\n         proxyIssuer = (localStorage.getItem(\"proxyIssuer\") == \"true\");\r\n\r\n\r\n         let html = this.html;\r\n\r\n         // We should have received a URL that was scanned as a QR code or as a redirection\r\n         // Perform some sanity checks on the parameter\r\n         if (qrData == null || !qrData.startsWith) {\r\n            myerror(\"The qrData parameter is not a string\");\r\n            gotoPage(\"ErrorPage\", {\r\n               title: \"No data received\",\r\n               msg: \"The qrData parameter is not a string\",\r\n            });\r\n            return;\r\n         }\r\n\r\n         // Make sure it is a fully qualified URL\r\n         if (!qrData.startsWith(\"https://\") && !qrData.startsWith(\"http://\")) {\r\n            myerror(\"The scanned QR does not contain a valid URL\");\r\n            gotoPage(\"ErrorPage\", {\r\n               title: \"No data received\",\r\n               msg: \"The scanned QR does not contain a valid URL\",\r\n            });\r\n            return;\r\n         }\r\n\r\n         // EBSI wallet conformance tests use redirections with these parameters\r\n         if (qrData.includes(\"state=\") && qrData.includes(\"auth-mock\")) {\r\n            gotoPage(\"EBSIRedirect\", qrData);\r\n            return;\r\n         }\r\n\r\n         // EBSI wallet conformance tests use redirections with these parameters\r\n         if (qrData.includes(\"code=\")) {\r\n            gotoPage(\"EBSIRedirectCode\", qrData);\r\n            return;\r\n         }\r\n\r\n         if (qrData.includes(\"credential_offer_uri=\")) {\r\n            // The QR points to an an OpenID4VCI credential issuance offer\r\n\r\n            // Retrieve the credential offer from the Issuer\r\n            // Until CORS is enabled in Issuer, send request via a server\r\n            this.credentialOffer = await getCredentialOffer(qrData, \"via_server\");\r\n\r\n            // Save temporarily for redirections which cause page reloads\r\n            await storage.settingsPut(\"credentialOffer\", this.credentialOffer);\r\n            mylog(\"credentialOffer\", this.credentialOffer);\r\n\r\n            // Get the credential_issuer url to retrieve its metadata\r\n            const credential_issuer = this.credentialOffer[\"credential_issuer\"];\r\n            if (!credential_issuer) {\r\n               let msg = \"credential_issuer object not found in credentialOffer\";\r\n               myerror(msg);\r\n               gotoPage(\"ErrorPage\", {\r\n                  title: \"Invalid credentialOffer\",\r\n                  msg: msg,\r\n               });\r\n               return;\r\n            }\r\n\r\n            // Get the Issuer metadata from the well-known endpoint of the Issuer\r\n            var issuerMetaData = await getIssuerMetadata(credential_issuer, \"via_server\");\r\n            mylog(\"issuerMetaData\", issuerMetaData);\r\n            this.issuerMetaData = issuerMetaData;\r\n            await storage.settingsPut(\"issuerMetaData\", issuerMetaData);\r\n\r\n            // Check that the credential endpoint url exists in the metadata\r\n            var credentialEndpoint = issuerMetaData[\"credential_endpoint\"];\r\n            if (!credentialEndpoint) {\r\n               let msg = \"credentialEndpoint object not found in issuerMetaData\";\r\n               myerror(msg);\r\n               gotoPage(\"ErrorPage\", {\r\n                  title: \"Invalid issuerMetaData\",\r\n                  msg: msg,\r\n               });\r\n               return;\r\n            }\r\n\r\n            // If the 'authorization_server' is not specified, use the same url as the issuer\r\n            var authorizationServer = issuerMetaData[\"authorization_server\"];\r\n            if (!authorizationServer) {\r\n               authorizationServer = issuerMetaData[\"credential_issuer\"];\r\n            }\r\n            if (!authorizationServer) {\r\n               let msg = \"'authorizationServer' object not found in issuerMetaData\";\r\n               myerror(msg);\r\n               gotoPage(\"ErrorPage\", {\r\n                  title: \"Invalid issuerMetaData\",\r\n                  msg: msg,\r\n               });\r\n               return;\r\n            }\r\n\r\n            // Get the AuthServer metadata from the well-known endpoint of the Authentication Server\r\n            var authServerMetaData = await getAuthServerMetadata(authorizationServer);\r\n            this.authServerMetaData = authServerMetaData;\r\n            await storage.settingsPut(\"authServerMetaData\", authServerMetaData);\r\n\r\n            // The grant object in the credential offer will determine the type of flow to execute\r\n            const grants = this.credentialOffer[\"grants\"];\r\n            if (!grants) {\r\n               let msg = \"grants object not found in credentialOffer\";\r\n               myerror(msg);\r\n               gotoPage(\"ErrorPage\", {\r\n                  title: \"Invalid credentialOffer\",\r\n                  msg: msg,\r\n               });\r\n               return;\r\n            }\r\n\r\n            // Check the type of authorization flows supported by Issuer\r\n            const authorization_code = grants[\"authorization_code\"];\r\n            if (authorization_code) {\r\n               await this.renderAuthCodeFlow(\r\n                  this.credentialOffer,\r\n                  issuerMetaData,\r\n                  authServerMetaData\r\n               );\r\n               return;\r\n            } else if (grants[PRE_AUTHORIZED_CODE_GRANT_TYPE]) {\r\n               await this.startPreAuthorizedCodeFlow();\r\n               return;\r\n            } else {\r\n               let msg = `Unsupported authorization flow type found in grants`;\r\n               myerror(msg);\r\n               gotoPage(\"ErrorPage\", { title: \"Invalid grants\", msg: msg });\r\n               return;\r\n            }\r\n         } else {\r\n            mylog(\"Non-standard issuance\");\r\n            // This is a non-standard nechanism to issue credentials (easier in controlled environments).\r\n            // We have received a URL that was scanned as a QR code.\r\n            // First we should do a GET to the URL to retrieve the VC.\r\n\r\n            const theurl = new URL(qrData);\r\n            this.OriginServer = theurl.origin;\r\n            console.log(\"Origin:\", this.OriginServer);\r\n\r\n            var result = await doGETJSON(qrData);\r\n\r\n            // Store some values to facilitate later retrieval\r\n            this.VC = result[\"credential\"];\r\n            this.VCId = result[\"id\"];\r\n            this.VCType = result[\"type\"];\r\n            this.VCStatus = result[\"status\"];\r\n\r\n            // We only process credentials in 'offered' or 'signed' status\r\n            if (this.VCStatus == \"offered\" || this.VCStatus == \"signed\") {\r\n               // Get the HTML for the credential\r\n               try {\r\n                  this.renderedVC = this.prerenderCredential(this.VC, this.VCType, this.VCStatus);\r\n               } catch (error) {\r\n                  this.showError(error.name, error.message);\r\n                  return;\r\n               }\r\n\r\n               if (this.VCStatus == \"offered\") {\r\n                  // The credential has been offered, and the user can authorise its issuance or not\r\n                  let theHtml = this.html`\r\n              <ion-card color=\"warning\">\r\n                <ion-card-content>\r\n                  <p>\r\n                    <b>\r\n                      ${T(\"You received a proposal for a Verifiable Credential\")}.\r\n                      ${T(\"You can accept it, or cancel the operation.\")}\r\n                    </b>\r\n                  </p>\r\n                </ion-card-content>\r\n              </ion-card>\r\n\r\n              ${this.renderedVC}\r\n            `;\r\n                  this.render(theHtml);\r\n                  return;\r\n               } else if (this.VCStatus == \"signed\") {\r\n                  // The credential is already signed. The user has the option to store it in her wallet\r\n                  let theHtml = this.html`\r\n              <ion-card color=\"warning\">\r\n                <ion-card-content>\r\n                  <p>\r\n                    <b>\r\n                      ${T(\"You received a Verifiable Credential\")}.\r\n                      ${T(\r\n                         \"You can save it in this device for easy access later, or cancel the operation.\"\r\n                      )}\r\n                    </b>\r\n                  </p>\r\n                </ion-card-content>\r\n              </ion-card>\r\n\r\n              ${this.renderedVC}\r\n            `;\r\n                  this.render(theHtml);\r\n                  return;\r\n               }\r\n            }\r\n\r\n            // The credential is not in a correct state. Present an error screen\r\n            this.showError(\r\n               \"Invalid credential\",\r\n               \"The credential is neither in 'offered' nor 'signed' status\"\r\n            );\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Updates a credential by sending a POST request to the credential endpoint.\r\n       *\r\n       * @param {string} proof - The JWT proof to include in the request.\r\n       * @param {string} credentialEndpoint - The URL of the credential endpoint.\r\n       * @returns {Promise<object>} The credential response from the server.\r\n       * @throws {Error} If the request fails or returns an error status.\r\n       */\r\n      async updateCredentialPOST(proof, credentialEndpoint) {\r\n         var credentialReq = {\r\n            // types: credentialTypes,\r\n            format: \"jwt_vc\",\r\n            proof: {\r\n               proof_type: \"jwt\",\r\n               jwt: proof,\r\n            },\r\n         };\r\n\r\n         console.log(\"Body \" + JSON.stringify(credentialReq));\r\n         let response = await fetch(credentialEndpoint, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n               \"Content-Type\": \"application/json\",\r\n               // 'Authorization': 'Bearer ' + accessToken\r\n            },\r\n            body: JSON.stringify(credentialReq),\r\n            mode: \"cors\",\r\n         });\r\n\r\n         if (response.ok) {\r\n            // The reply is the complete JWT\r\n            const credentialResponse = await response.json();\r\n            mylog(credentialResponse);\r\n            return credentialResponse;\r\n         } else {\r\n            if (response.status == 400) {\r\n               throw new Error(\"Bad request 400 retrieving credential\");\r\n            } else {\r\n               throw new Error(response.statusText);\r\n            }\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Starts the pre-authorized code flow by prompting the user for the PIN that the Issuer sent.\r\n       *\r\n       * @returns {Promise<void>}\r\n       */\r\n      async startPreAuthorizedCodeFlow() {\r\n         let theHtml = this.html`\r\n        <ion-card style=\"max-width:600px\">\r\n          <ion-card-content>\r\n            <p>Enter the PIN you have received in your email.</p>\r\n            <ion-input\r\n              id=\"thepin\"\r\n              label=\"PIN\"\r\n              label-placement=\"stacked\"\r\n              type=\"number\"\r\n              placeholder=\"0000\"\r\n            ></ion-input>\r\n          </ion-card-content>\r\n\r\n          <div class=\"ion-margin-start ion-margin-bottom\">\r\n            <ion-button\r\n              @click=${async () => {\r\n                 const ionpin = document.getElementById(\"thepin\");\r\n                 const nativepin = await ionpin.getInputElement();\r\n                 const pin = nativepin.value;\r\n                 if (pin.length > 0) {\r\n                    this.renderPreAuthorizedCodeFlow(pin);\r\n                 }\r\n              }}\r\n            >\r\n              ${T(\"Continue\")}\r\n            </ion-button>\r\n          </div>\r\n        </ion-card>\r\n      `;\r\n         this.render(theHtml);\r\n      }\r\n\r\n      /**\r\n       * Renders the pre-authorized code flow after the user has entered the PIN.\r\n       *\r\n       * @param {string} user_pin - The PIN entered by the user.\r\n       * @returns {Promise<void>}\r\n       */\r\n      async renderPreAuthorizedCodeFlow(user_pin) {\r\n         try {\r\n            this.user_pin = user_pin;\r\n            const jwtCredential = await performPreAuthorizedCodeFlow(\r\n               this.credentialOffer,\r\n               this.issuerMetaData,\r\n               this.authServerMetaData,\r\n               user_pin\r\n            );\r\n            if (!jwtCredential) {\r\n               myerror(\"No credential received\");\r\n               this.showError(\r\n                  \"No credential received\",\r\n                  \"The server did not return a valid credential\"\r\n               );\r\n               return;\r\n            }\r\n\r\n            // Store in an instance variable\r\n            this.VC = jwtCredential;\r\n            this.VCType = \"jwt_vc_json\";\r\n            this.VCStatus = \"signed\";\r\n\r\n            // Decode and render the credencial\r\n            const decoded = decodeUnsafeJWT(jwtCredential);\r\n\r\n            // Get the HTML for the credential\r\n            try {\r\n               this.renderedVC = this.prerenderCredential(this.VC, this.VCType, this.VCStatus);\r\n            } catch (error) {\r\n               this.showError(error.name, error.message);\r\n               return;\r\n            }\r\n\r\n            // Ask the user if we should store the VC\r\n            let theHtml = this.html`\r\n            <ion-card color=\"warning\">\r\n               <ion-card-content>\r\n               <p>\r\n                  <b>\r\n                     ${T(\"You received a Verifiable Credential\")}.\r\n                     ${T(\r\n                        \"You can save it in this device for easy access later, or cancel the operation.\"\r\n                     )}\r\n                  </b>\r\n               </p>\r\n               </ion-card-content>\r\n            </ion-card>\r\n\r\n            ${this.renderedVC}\r\n            `;\r\n            this.render(theHtml);\r\n         } catch (error) {\r\n            debugger;\r\n            myerror(error);\r\n            this.showError(error.name, error.message);\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Renders the authorization code flow.\r\n       *\r\n       * @param {object} credentialOffer - The credential offer object.\r\n       * @param {object} issuerMetaData - The issuer metadata object.\r\n       * @param {object} authServerMetaData - The authorization server metadata object.\r\n       * @returns {Promise<void>}\r\n       */\r\n      async renderAuthCodeFlow(credentialOffer, issuerMetaData, authServerMetaData) {\r\n         const jwtCredential = await performAuthCodeFlow(\r\n            credentialOffer,\r\n            issuerMetaData,\r\n            authServerMetaData\r\n         );\r\n\r\n         // Store in an instance variable\r\n         this.VC = jwtCredential;\r\n         this.VCType = \"EBSI\";\r\n\r\n         // Decode and render the credencial\r\n         const decoded = decodeUnsafeJWT(jwtCredential);\r\n         this.renderedVC = this.renderEBSICredential(decoded);\r\n\r\n         // Ask the user if we should store the VC\r\n         let theHtml = this.html`\r\n        <ion-card color=\"warning\">\r\n          <ion-card-content>\r\n            <p>\r\n              <b>\r\n                ${T(\"You received a Verifiable Credential\")}.\r\n                ${T(\r\n                   \"You can save it in this device for easy access later, or cancel the operation.\"\r\n                )}\r\n              </b>\r\n            </p>\r\n          </ion-card-content>\r\n        </ion-card>\r\n\r\n        ${this.renderedVC}\r\n      `;\r\n         this.render(theHtml);\r\n      }\r\n\r\n      /**\r\n       * Accepts a credential offer by updating it with the user's DID and sending it back to the server.\r\n       *\r\n       * @returns {Promise<void>}\r\n       */\r\n      async acceptVC() {\r\n         console.log(\"Accept VC \" + this.VC);\r\n         if (this.VCStatus == \"offered\") {\r\n            // We should update the credential offer with the did of the user\r\n\r\n            var myDid = await getOrCreateDidKey();\r\n            const theProof = await generateDIDKeyProof(myDid, this.OriginServer, \"1234567890\");\r\n            debugger;\r\n            var result = await this.updateCredentialPOST(theProof, this.qrData);\r\n            console.log(\"acceptVC\", result);\r\n\r\n            // Display result page\r\n            gotoPage(\"VCAcceptedPage\");\r\n            return;\r\n         }\r\n      }\r\n\r\n      /**\r\n       * Saves the Verifiable Credential (VC) to the local storage.\r\n       *\r\n       * @returns {Promise<void>}\r\n       */\r\n      async saveVC() {\r\n         var replace = false;\r\n\r\n         console.log(\"Save VC \" + this.VC);\r\n\r\n         if (this.VCType == \"jwt_vc_json\") {\r\n            debugger;\r\n            // The credential is in JWT format, lets decode it\r\n            const decoded = decodeUnsafeJWT(this.VC);\r\n\r\n            // Prepare for saving the credential in the local storage\r\n            var credStruct = {\r\n               type: this.VCType,\r\n               status: \"signed\",\r\n               encoded: this.VC,\r\n               decoded: decoded.body?.vc,\r\n               id: decoded.body.jti,\r\n            };\r\n\r\n            // Save the credential, if there is no other one with the same id\r\n            var saved = await credentialsSave(credStruct, false);\r\n            if (!saved) {\r\n               return;\r\n            }\r\n\r\n            alert(\"Credential succesfully saved\");\r\n            // Reload the application with a clean URL\r\n            location = window.location.origin + window.location.pathname;\r\n         } else if (this.VCType == \"EBSI\") {\r\n            const decodedJWT = decodeUnsafeJWT(this.VC);\r\n            const decoded = decodedJWT.body.vc;\r\n\r\n            var credStruct = {\r\n               type: \"EBSI\",\r\n               status: this.VCStatus,\r\n               encoded: this.VC,\r\n               decoded: decoded,\r\n            };\r\n            var saved = await credentialsSave(credStruct, replace);\r\n            if (!saved) {\r\n               return;\r\n            }\r\n         } else if (this.VCType == \"jwt_vc\") {\r\n            debugger;\r\n\r\n            if (this.VCStatus == \"offered\") {\r\n               // We should update the credential offer with the did of the user\r\n\r\n               var myDid = await getOrCreateDidKey();\r\n\r\n               // Update the credential with the did:key\r\n               var sendidRequest = {\r\n                  did: myDid.did,\r\n               };\r\n\r\n               // Send the DID to the Issuer\r\n               const senddidURL = `${this.OriginServer}/apiuser/senddid/${this.VCId}`;\r\n               var result = await doPOST(senddidURL, sendidRequest);\r\n               if (!result) {\r\n                  return;\r\n               }\r\n               console.log(\"after doPOST sending the DID\");\r\n\r\n               // We received back the updated credential. Status must be 'tobesigned'\r\n               this.VC = result[\"credential\"];\r\n               this.VCId = result[\"id\"];\r\n               this.VCType = result[\"type\"];\r\n               this.VCStatus = result[\"status\"];\r\n            }\r\n\r\n            // The credential is in JWT format, lets decode it\r\n            const decoded = decodeUnsafeJWT(this.VC);\r\n\r\n            // Prepare for saving the credential in the local storage\r\n            var credStruct = {\r\n               type: this.VCType,\r\n               status: this.VCStatus,\r\n               encoded: this.VC,\r\n               decoded: decoded.body,\r\n               id: decoded.body.id,\r\n            };\r\n\r\n            // If the credential already exists, we only replace it if it is 'signed'\r\n            if (this.VCStatus == \"signed\") {\r\n               replace = true;\r\n            }\r\n            var saved = await credentialsSave(credStruct, replace);\r\n            if (!saved) {\r\n               return;\r\n            }\r\n\r\n            alert(\"Credential succesfully saved\");\r\n         } else {\r\n            const decoded = JSON.parse(this.VC);\r\n\r\n            var credStruct = {\r\n               type: \"w3cvc\",\r\n               status: this.VCStatus,\r\n               encoded: this.VC,\r\n               decoded: decoded,\r\n            };\r\n            var saved = await credentialsSave(credStruct, replace);\r\n            if (!saved) {\r\n               return;\r\n            }\r\n         }\r\n\r\n         // Reload the application with a clean URL\r\n         location = window.location.origin + window.location.pathname;\r\n         return;\r\n      }\r\n\r\n      /**\r\n       * Reloads the application with a clean URL.\r\n       *\r\n       * @returns {void}\r\n       */\r\n      cleanReload() {\r\n         // Reload the application with a clean URL\r\n         location = window.location.origin + window.location.pathname;\r\n         return;\r\n      }\r\n\r\n      /**\r\n       * Renders an EBSI credential.\r\n       *\r\n       * @param {object} vcdecoded - The decoded credential object.\r\n       * @returns {HTMLElement} The rendered HTML element.\r\n       */\r\n      renderEBSICredential(vcdecoded) {\r\n         const vc = vcdecoded.body.vc;\r\n         const vcTypeArray = vc[\"type\"];\r\n\r\n         // Get the last element of the array\r\n         const vcType = vcTypeArray[vcTypeArray.length - 1];\r\n\r\n         const div = this.html`\r\n        <ion-card>\r\n          <ion-card-header>\r\n            <ion-card-title>${vcType}</ion-card-title>\r\n            <ion-card-subtitle>EBSI</ion-card-subtitle>\r\n          </ion-card-header>\r\n\r\n          <ion-card-content class=\"ion-padding-bottom\">\r\n            <div>\r\n              <p>Issuer: ${vc.issuer}</p>\r\n            </div>\r\n          </ion-card-content>\r\n\r\n          <div class=\"ion-margin-start ion-margin-bottom\">\r\n            <ion-button @click=${() => this.cleanReload()}>\r\n              <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n              ${T(\"Do not save\")}\r\n            </ion-button>\r\n\r\n            <ion-button @click=${() => this.saveVC()}>\r\n              <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n              ${T(\"Save credential\")}\r\n            </ion-button>\r\n          </div>\r\n        </ion-card>\r\n      `;\r\n         return div;\r\n      }\r\n\r\n      /**\r\n       * Pre-renders a credential based on its type and status.\r\n       *\r\n       * @param {string} vcencoded - The encoded credential.\r\n       * @param {string} vctype - The type of the credential.\r\n       * @param {string} vcstatus - The status of the credential.\r\n       * @returns {HTMLElement} The rendered HTML element.\r\n       */\r\n      prerenderCredential(vcencoded, vctype, vcstatus) {\r\n         if (vctype == \"jwt_vc\" || vctype == \"jwt_vc_json\") {\r\n            var decoded = decodeUnsafeJWT(vcencoded);\r\n         } else {\r\n            decoded = vcencoded;\r\n         }\r\n\r\n         if (vctype == \"jwt_vc_json\") {\r\n            const vc = decoded.body.vc;\r\n            const credCard = renderAnyCredentialCard(vc, vcstatus);\r\n\r\n            return this.html`\r\n            <ion-card>\r\n              ${credCard}\r\n    \r\n              <div class=\"ion-margin-start ion-margin-bottom\">\r\n                <ion-button @click=${() => this.cleanReload()}>\r\n                  <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                  ${T(\"Do not save\")}\r\n                </ion-button>\r\n    \r\n                <ion-button @click=${() => this.saveVC()}>\r\n                  <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n                  ${T(\"Save credential\")}\r\n                </ion-button>\r\n              </div>\r\n            </ion-card>\r\n            `;\r\n         }\r\n\r\n         const vc = decoded.body;\r\n\r\n         const vctypes = vc.type;\r\n\r\n         const credCard = renderAnyCredentialCard(vc, vcstatus);\r\n\r\n         let html = this.html;\r\n\r\n         if (vcstatus == \"offered\") {\r\n            const div = this.html`\r\n          <ion-card>\r\n            ${credCard}\r\n\r\n            <div class=\"ion-margin-start ion-margin-bottom\">\r\n              <ion-button @click=${() => this.cleanReload()}>\r\n                <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n                ${T(\"Cancel\")}\r\n              </ion-button>\r\n\r\n              <ion-button @click=${() => this.acceptVC()}>\r\n                <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n                ${T(\"Accept credential offer\")}\r\n              </ion-button>\r\n            </div>\r\n          </ion-card>\r\n        `;\r\n            return div;\r\n         }\r\n\r\n         const div = this.html`\r\n        <ion-card>\r\n          ${credCard}\r\n\r\n          <div class=\"ion-margin-start ion-margin-bottom\">\r\n            <ion-button @click=${() => this.cleanReload()}>\r\n              <ion-icon slot=\"start\" name=\"chevron-back\"></ion-icon>\r\n              ${T(\"Do not save\")}\r\n            </ion-button>\r\n\r\n            <ion-button @click=${() => this.saveVC()}>\r\n              <ion-icon slot=\"start\" name=\"person-add\"></ion-icon>\r\n              ${T(\"Save credential\")}\r\n            </ion-button>\r\n          </div>\r\n        </ion-card>\r\n      `;\r\n         return div;\r\n      }\r\n   }\r\n);\r\n\r\n/**\r\n * Performs the authorization code flow for credential issuance.\r\n *\r\n * @param {object} credentialOffer - The credential offer object.\r\n * @param {object} issuerMetaData - The issuer metadata object.\r\n * @param {object} authServerMetaData - The authorization server metadata object.\r\n * @returns {Promise<string>} The issued credential in JWT format.\r\n * @throws {Error} If any step in the flow fails.\r\n */\r\nasync function performAuthCodeFlow(credentialOffer, issuerMetaData, authServerMetaData) {\r\n   // Get the credential supported by issuer\r\n   const credentialTypes = credentialOffer.credentials[0].types;\r\n\r\n   // The state will be used by the issuer to match request/reply\r\n   const issuer_state = credentialOffer[\"grants\"][\"authorization_code\"][\"issuer_state\"];\r\n\r\n   // This is the url of the Authorization Server\r\n   const authorization_endpoint = authServerMetaData[\"authorization_endpoint\"];\r\n\r\n   // Get my DID\r\n   const myDID = await window.MHR.storage.didFirst();\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 1: GET Authorization Request\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 1: GET Authorization Request\");\r\n\r\n   // It has the following form:\r\n   //\r\n   // GET from https://api-conformance.ebsi.eu/conformance/v3/auth-mock/authorize\r\n   // ?response_type=code\r\n   // &scope=openid\r\n   // &state=tracker%3Dvcfghhj\r\n   // &client_id=did%3Akey%3Az2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbsEYvdrjxMjQ4tpnje9BDBTzuNDP3knn6qLZErzd4bJ5go2CChoPjd5GAH3zpFJP5fuwSk66U5Pq6EhF4nKnHzDnznEP8fX99nZGgwbAh1o7Gj1X52Tdhf7U4KTk66xsA5r\r\n   // &authorization_details=%5B%7B%22type%22%3A%22openid_credential%22%2C%22format%22%3A%22jwt_vc%22%2C%22types%22%3A%5B%22VerifiableCredential%22%2C%22VerifiableAttestation%22%2C%22CTWalletInTime%22%5D%7D%5D\r\n   // &redirect_uri=openid%3A\r\n   // &nonce=glkFFoisdfEui43\r\n   // &code_challenge=YjI0ZTQ4NTBhMzJmMmZhNjZkZDFkYzVhNzlhNGMyZDdjZDlkMTM4YTY4NjcyMTA5M2Q2OWQ3YjNjOGJlZDBlMSAgLQo%3D\r\n   // &code_challenge_method=S256\r\n   // &client_metadata=%7B%22vp_formats_supported%22%3A%7B%22jwt_vp%22%3A%7B%22alg%22%3A%5B%22ES256%22%5D%7D%2C%22jwt_vc%22%3A%7B%22alg%22%3A%5B%22ES256%22%5D%7D%7D%2C%22response_types_supported%22%3A%5B%22vp_token%22%2C%22id_token%22%5D%2C%22authorization_endpoint%22%3A%22openid%3A%22%7D\r\n\r\n   // Calculate a code_challenge as BASE64URL-ENCODE(SHA256(code_verifier as UTF-8 string))\r\n   // Where code_verifier is a secure random, which will be used with token endpoint.\r\n   // It is between 43 and 128 characters long, and contains characters A-Z, a-z, 0-9, hyphen, period, underscore, and tilde.\r\n   // See RFC 7636 for more information\r\n   // TODO: should generate a random string\r\n   const code_verifier = \"this_is_a_code_verifierthis_is_a_code_verifierthis_is_a_code_verifier\";\r\n   const code_challenge = await hashFromString(code_verifier);\r\n   console.log(\"code_challenge\", code_challenge);\r\n\r\n   // Specify what we are requesting\r\n   var authorization_details = [\r\n      {\r\n         type: \"openid_credential\",\r\n         format: \"jwt_vc\",\r\n         types: credentialTypes,\r\n      },\r\n   ];\r\n\r\n   // If the Credential Issuer metadata contains an authorization_server parameter,\r\n   // the authorization detail's locations common data field MUST be set to the Credential Issuer Identifier value.\r\n   var authorizationServer = issuerMetaData[\"authorization_server\"];\r\n   if (authorizationServer) {\r\n      authorization_details[0][\"locations\"] = [issuerMetaData[\"credential_issuer\"]];\r\n   }\r\n\r\n   var client_metadata = {\r\n      vp_formats_supported: {\r\n         jwt_vp: { alg: [\"ES256\"] },\r\n         jwt_vc: { alg: [\"ES256\"] },\r\n      },\r\n      response_types_supported: [\"vp_token\", \"id_token\"],\r\n      authorization_endpoint: window.location.origin,\r\n   };\r\n\r\n   var formAttributes = {\r\n      response_type: \"code\",\r\n      scope: \"openid\",\r\n      issuer_state: issuer_state,\r\n      client_id: myDID.did,\r\n      authorization_details: JSON.stringify(authorization_details),\r\n      redirect_uri: window.location.origin,\r\n      nonce: \"thisisthenonce\",\r\n      code_challenge: code_challenge,\r\n      code_challenge_method: \"S256\",\r\n      client_metadata: JSON.stringify(client_metadata),\r\n   };\r\n   // Encode in urlForm\r\n   var formBody = [];\r\n   for (var property in formAttributes) {\r\n      var encodedKey = encodeURIComponent(property);\r\n      var encodedValue = encodeURIComponent(formAttributes[property]);\r\n      formBody.push(encodedKey + \"=\" + encodedValue);\r\n   }\r\n   formBody = formBody.join(\"&\");\r\n\r\n   // There will be an HTTP 302 Redirection after this\r\n   // We will receive the url to invoke as a result from the POST\r\n   debugger;\r\n   console.log(\"AuthRequest\", authorization_endpoint + \"?\" + formBody);\r\n   let resp = await fetch(authorization_endpoint + \"?\" + formBody, {\r\n      cache: \"no-cache\",\r\n      mode: \"cors\",\r\n   });\r\n\r\n   // Throw an error if something went wrong\r\n   if (!resp.ok || !resp.redirected) {\r\n      throw new Error(\"error retrieving OpenID metadata\");\r\n   }\r\n\r\n   var redirectedURL = resp.url;\r\n   mylog(redirectedURL);\r\n   var urlParams = new URL(redirectedURL).searchParams;\r\n\r\n   const response_type = decodeURIComponent(urlParams.get(\"response_type\"));\r\n   if (response_type == \"vp_token\") {\r\n      const pd = decodeURIComponent(urlParams.get(\"presentation_definition\"));\r\n      console.log(\"Presentation Definition\", pd);\r\n      throw new Error(\"Response type vp_token not implemented yet\");\r\n   } else if (response_type == \"id_token\") {\r\n      // Do nothing. This is for documentation purposes\r\n   } else {\r\n      throw new Error(\"Invalid response_type: \" + response_type);\r\n   }\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 2: ID Token Request\r\n   //\r\n   // The authorization server requests an ID Token from the Wallet to authenticate the DID without any claims.\r\n   // The request from the Auth Server comes in the redirected URL received as a response of the authorization request.\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 2: ID Token Request\");\r\n\r\n   const redirect_uri = decodeURIComponent(urlParams.get(\"redirect_uri\"));\r\n   console.log(\"redirect_uri\", redirect_uri);\r\n   const client_id = decodeURIComponent(urlParams.get(\"client_id\"));\r\n   const state = decodeURIComponent(urlParams.get(\"state\"));\r\n   var nonce = decodeURIComponent(urlParams.get(\"nonce\"));\r\n\r\n   // Generate the ID Token according to the request from the authorization server\r\n   const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce);\r\n   console.log(\"IDToken\", IDToken);\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 3: Send ID Token Response to Authorization Server\r\n   //\r\n   // The Wallet answers the ID Token Request by providing the id_token in the redirect_uri as instructed by response_mode\r\n   // of direct_post. The id_token must be signed with the DID document's authentication key.\r\n   // The state parameter is mandatory for the ID Token Response when it is present in the ID Token Request sent by\r\n   // the Authorization Server. In such cases, the Wallet must ensure that the values of the state parameter are identical in both.\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 2: ID Token Request\");\r\n\r\n   var formAttributes = {\r\n      id_token: IDToken,\r\n      state: state,\r\n   };\r\n\r\n   formBody = [];\r\n   for (var property in formAttributes) {\r\n      var encodedKey = encodeURIComponent(property);\r\n      var encodedValue = encodeURIComponent(formAttributes[property]);\r\n      formBody.push(encodedKey + \"=\" + encodedValue);\r\n   }\r\n   formBody = formBody.join(\"&\");\r\n   console.log(\"Body\", formBody);\r\n\r\n   // There will be an HTTP 302 Redirection after this\r\n   // We will receive the url to invoke as a result from the POST\r\n   resp = await fetch(redirect_uri, {\r\n      method: \"POST\",\r\n      redirect: \"follow\",\r\n      cache: \"no-cache\",\r\n      headers: {\r\n         \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: formBody,\r\n      mode: \"cors\",\r\n   });\r\n\r\n   // Throw an error if something went wrong\r\n   if (!resp.ok || !resp.redirected) {\r\n      throw new Error(resp.statusText);\r\n   }\r\n\r\n   redirectedURL = resp.url;\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 4: Receive Authorization response\r\n   //\r\n   // The redirected URL contains the Authorization Response, with the authorization code. The url is something like:\r\n   // https://wallet.mycredential.eu?code=530dfe71-845b-4310-acb6-06023a036ff5\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 4: Receive Authorization response\");\r\n   mylog(redirectedURL);\r\n   var urlParams = new URL(redirectedURL).searchParams;\r\n\r\n   // Get the authorization code from the URL\r\n   const code = decodeURIComponent(urlParams.get(\"code\"));\r\n   console.log(\"code\", code);\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 5: Request Access Token from Authorization Server\r\n   //\r\n   // The Wallet (Relying Party) proceeds with the code flow by calling the Token Endpoint with the required details\r\n   // and providing a code_verifier corresponding to the initial Authorisation Request code_challenge.\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 5: Request Access Token from Authorization Server\");\r\n\r\n   const tokenEndpoint = authServerMetaData.token_endpoint;\r\n\r\n   var formAttributes = {\r\n      grant_type: \"authorization_code\",\r\n      client_id: myDID.did,\r\n      code: code,\r\n      code_verifier: code_verifier,\r\n   };\r\n   formBody = encodeFormAttributes(formAttributes);\r\n   console.log(tokenEndpoint);\r\n   console.log(formBody);\r\n\r\n   // This request is a normal one and will not be redirected\r\n   resp = await fetch(tokenEndpoint, {\r\n      method: \"POST\",\r\n      redirect: \"follow\",\r\n      cache: \"no-cache\",\r\n      headers: {\r\n         \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n      },\r\n      body: formBody,\r\n      mode: \"cors\",\r\n   });\r\n\r\n   if (!resp.ok) {\r\n      throw new Error(resp.statusText);\r\n   }\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 6: Receive Access Token from Authorization Server\r\n   //\r\n   // The Access Token is delivered inside a response payload from a successful Token Endpoint initiation.\r\n   // c_nonce (Challenge Nonce) must be stored until a new one is given. The response looks like:\r\n   //\r\n   // Content-Type: application/json\r\n   // {\r\n   //     \"access_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI6Ikp..sHQ\",\r\n   //     \"refresh_token\": \"eyJhbGciOiJSUzI1NiIsInR5cCI4a5k..zEF\",\r\n   //     \"token_type\": \"bearer\",\r\n   //     \"expires_in\": 86400,\r\n   //     \"id_token\": \"eyJodHRwOi8vbWF0dHIvdGVuYW50L..3Mz\",\r\n   //     \"c_nonce\": \"PAPPf3h9lexTv3WYHZx8ajTe\",\r\n   //     \"c_nonce_expires_in\": 86400\r\n   // }\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 6: Receive Access Token from Authorization Server\");\r\n\r\n   const authTokenObject = await resp.json();\r\n   console.log(\"Auth Token object:\", authTokenObject);\r\n\r\n   // Get the nonce and access token from the retrieved object\r\n   var nonce = authTokenObject.c_nonce;\r\n   const access_token = authTokenObject.access_token;\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 7: Send a Credential Request\r\n   //\r\n   // At this point, the Wallet has successfully obtained a valid Access Token, which can be used to gain access to\r\n   // the Credential's Issuer.\r\n   // The Relying Party proceeds by requesting issuance of the Verifiable Credential from the Issuer Mock.\r\n   // The requested Credential must match the granted access. The DID document's authentication key must be used\r\n   // for signing the JWT proof, where the DID must also match the one used for authentication.\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 7: Send a Credential Request\");\r\n\r\n   // Get the proof object that we have to include in the Credential Request\r\n   const proof = await generateDIDKeyProof(myDID, issuerMetaData.credential_issuer, nonce);\r\n\r\n   // Get the credential from EBSI\r\n   var credentialResponse = await requestCredential(\r\n      proof,\r\n      access_token,\r\n      issuerMetaData.credential_endpoint,\r\n      credentialTypes\r\n   );\r\n\r\n   var acceptance_token = credentialResponse[\"acceptance_token\"];\r\n   const max_iterations = 10;\r\n   var iterations = 0;\r\n\r\n   while (acceptance_token && iterations < max_iterations) {\r\n      console.log(\"Waiting for credential ...\");\r\n      await delay(1000);\r\n      console.log(\"Finished waiting for credential\");\r\n\r\n      // Get the credential from EBSI\r\n\r\n      credentialResponse = await requestDeferredEBSICredential(\r\n         acceptance_token,\r\n         issuerMetaData[\"deferred_credential_endpoint\"]\r\n      );\r\n      // credentialResponse = await requestEBSICredential(proof, acceptance_token, issuerMetaData.credential_endpoint, credentialTypes)\r\n      console.log(\"CredentialResponse\", credentialResponse);\r\n      acceptance_token = credentialResponse[\"acceptance_token\"];\r\n\r\n      iterations = iterations + 1;\r\n   }\r\n\r\n   if (!credentialResponse.credential) {\r\n      throw new Error(\"No credential after all retries\");\r\n   }\r\n\r\n   // **************************************\r\n   // **************************************\r\n   // Step 8: Receive the credential\r\n   //\r\n   // After a successful request, the response payload will contain the requested credential. It looks like:\r\n   //\r\n   // Content-Type: application/json\r\n   // {\r\n   //   \"format\": \"jwt_vc\",\r\n   //   \"credential\": \"eyJ0eXAiOiJKV1QiLCJhbGciOi...Y5kwU_qJzvBWEVsBP8QvRlLvcWJDwyyGJF0YluuK2Cog\",\r\n   // }\r\n   //\r\n   // **************************************\r\n   // **************************************\r\n   console.log(\"Step 8: Receive the credential\");\r\n\r\n   return credentialResponse.credential;\r\n}\r\n\r\nfunction delay(ms) {\r\n   return new Promise((resolve) => setTimeout(resolve, ms));\r\n}\r\n\r\nasync function performPreAuthorizedCodeFlow(\r\n   credentialOffer,\r\n   issuerMetaData,\r\n   authServerMetaData,\r\n   user_pin\r\n) {\r\n   console.log(\"credentialOffer\");\r\n   console.log(credentialOffer);\r\n\r\n   console.log(\"issuerMetaData\");\r\n   console.log(issuerMetaData);\r\n\r\n   console.log(\"authServerMetaData\");\r\n   console.log(authServerMetaData);\r\n\r\n   // Get the credential supported by issuer\r\n   const credentialTypes = credentialOffer.credentials[0].types;\r\n\r\n   // Get an accesstoken for retrieving the credential\r\n   const tokenEndpoint = authServerMetaData[\"token_endpoint\"];\r\n   const code = credentialOffer[\"grants\"][PRE_AUTHORIZED_CODE_GRANT_TYPE][\"pre-authorized_code\"];\r\n   const authTokenObject = await getPreAuthToken(tokenEndpoint, code, user_pin, \"via_server\");\r\n\r\n   // Get the nonce and access token from the retrieved object\r\n   const nonce = authTokenObject.c_nonce;\r\n   const access_token = authTokenObject.access_token;\r\n\r\n   // Get my DID\r\n   // const myDID = await window.MHR.storage.didFirst();\r\n\r\n   var myDID = localStorage.getItem(\"domedid\");\r\n   myDID = JSON.parse(myDID);\r\n\r\n   // Get the proof object that we have to include in the Credential Request\r\n   const proof = await generateDIDKeyProof(myDID, issuerMetaData.credential_issuer, nonce);\r\n\r\n   // Get the credential\r\n   const credentialResponse = await requestCredential(\r\n      proof,\r\n      access_token,\r\n      issuerMetaData.credential_endpoint,\r\n      credentialTypes\r\n   );\r\n\r\n   return credentialResponse.credential;\r\n}\r\n\r\nasync function getPreAuthToken(tokenEndpoint, preAuthCode, user_pin) {\r\n   // Build the structure to send to the server\r\n   var formAttributes = {\r\n      grant_type: PRE_AUTHORIZED_CODE_GRANT_TYPE,\r\n      tx_code: user_pin,\r\n      \"pre-authorized_code\": preAuthCode,\r\n   };\r\n\r\n   // Encode in 'application/x-www-form-urlencoded' the body\r\n   var formBody = [];\r\n   for (var property in formAttributes) {\r\n      var encodedKey = encodeURIComponent(property);\r\n      var encodedValue = encodeURIComponent(formAttributes[property]);\r\n      formBody.push(encodedKey + \"=\" + encodedValue);\r\n   }\r\n   formBody = formBody.join(\"&\");\r\n   mylog(\"getPreAuthToken Body: \" + formBody);\r\n\r\n   // Send to server\r\n   var tokenBody = await doPOST(tokenEndpoint, formBody, \"application/x-www-form-urlencoded\");\r\n\r\n   mylog(\"getPreAuthToken tokenBody:\", tokenBody);\r\n   return tokenBody;\r\n}\r\n\r\nasync function requestCredential(proof, accessToken, credentialEndpoint, credentialTypes) {\r\n   debugger;\r\n   var credentialReq = {\r\n      types: credentialTypes,\r\n      format: \"jwt_vc_json\",\r\n      proof: {\r\n         proof_type: \"jwt\",\r\n         jwt: proof,\r\n      },\r\n   };\r\n\r\n   var credentialResponse = await doPOST(\r\n      credentialEndpoint,\r\n      credentialReq,\r\n      \"application/json\",\r\n      accessToken\r\n   );\r\n   mylog(credentialResponse);\r\n   return credentialResponse;\r\n}\r\n\r\nasync function requestDeferredEBSICredential(acceptance_token, deferredCredentialEndpoint) {\r\n   let response = await fetch(deferredCredentialEndpoint, {\r\n      method: \"POST\",\r\n      cache: \"no-cache\",\r\n      headers: {\r\n         \"Content-Type\": \"application/json\",\r\n         Authorization: \"Bearer \" + acceptance_token,\r\n      },\r\n      mode: \"cors\",\r\n   });\r\n\r\n   if (response.ok) {\r\n      // The reply is the complete JWT\r\n      const credentialResponse = await response.json();\r\n      mylog(credentialResponse);\r\n      return credentialResponse;\r\n   } else {\r\n      throw new Error(response.statusText);\r\n   }\r\n}\r\n\r\nasync function getCredentialOIDC4VCI(credentialEndpoint, accessToken, format, credential_type) {\r\n   try {\r\n      var credentialReq = {\r\n         format: format,\r\n         types: credential_type,\r\n      };\r\n      console.log(\"Body \" + JSON.stringify(credentialReq));\r\n      let response = await fetch(credentialEndpoint, {\r\n         method: \"POST\",\r\n         cache: \"no-cache\",\r\n         headers: {\r\n            \"Content-Type\": \"application/json\",\r\n            Authorization: \"Bearer \" + accessToken,\r\n         },\r\n         body: JSON.stringify(credentialReq),\r\n         mode: \"cors\",\r\n      });\r\n      if (response.ok) {\r\n         var credentialBody = await response.json();\r\n      } else {\r\n         if (response.status == 403) {\r\n            alert.apply(\"error 403\");\r\n            window.MHR.goHome();\r\n            return \"Error 403\";\r\n         }\r\n         var error = await response.text();\r\n         myerror(error);\r\n         window.MHR.goHome();\r\n         alert(error);\r\n         return null;\r\n      }\r\n   } catch (error2) {\r\n      myerror(error2);\r\n      alert(error2);\r\n      return null;\r\n   }\r\n   console.log(credentialBody);\r\n   return credentialBody;\r\n}\r\n\r\n/**\r\n * Retrieves the OpenID Credential Issuer metadata from the specified issuer address.\r\n *\r\n * @async\r\n * @function getIssuerMetadata\r\n * @param {string} issuerAddress - The base URL of the OpenID Credential Issuer.\r\n * @returns {Promise<object>} A promise that resolves with the issuer metadata object.\r\n * @throws {Error} Throws an error if the request fails or the response is not valid JSON.\r\n */\r\nasync function getIssuerMetadata(issuerAddress) {\r\n   mylog(\"IssuerMetadata at\", issuerAddress + \"/.well-known/openid-credential-issuer\");\r\n   var openIdInfo = await doGETJSON(issuerAddress + \"/.well-known/openid-credential-issuer\");\r\n   return openIdInfo;\r\n}\r\n\r\n/**\r\n * Retrieves the OpenID Authorization Server metadata from the specified authorization server address.\r\n *\r\n * @async\r\n * @function getAuthServerMetadata\r\n * @param {string} authServerAddress - The base URL of the OpenID Authorization Server.\r\n * @returns {Promise<object>} A promise that resolves with the authorization server metadata object.\r\n * @throws {Error} Throws an error if the request fails or the response is not valid JSON.\r\n */\r\nasync function getAuthServerMetadata(authServerAddress) {\r\n   mylog(\"AuthServerMetadata at\", authServerAddress);\r\n   var openIdInfo = await doGETJSON(authServerAddress + \"/.well-known/openid-configuration\");\r\n   return openIdInfo;\r\n}\r\n\r\n/**\r\n * Retrieves a credential offer from the specified URL.\r\n *\r\n * @async\r\n * @function getCredentialOffer\r\n * @param {string} url - The URL containing the credential offer URI.\r\n * @returns {Promise<object>} A promise that resolves with the credential offer object.\r\n * @throws {Error} Throws an error if the request fails or the response is not valid JSON.\r\n */\r\nasync function getCredentialOffer(url) {\r\n   const urlParams = new URL(url).searchParams;\r\n   const credentialOfferURI = decodeURIComponent(urlParams.get(\"credential_offer_uri\"));\r\n   console.log(\"Get: \" + credentialOfferURI);\r\n\r\n   var credentialOffer = await doGETJSON(credentialOfferURI);\r\n   console.log(credentialOffer);\r\n   return credentialOffer;\r\n}\r\n\r\n/**\r\n * Returns the string representation of the SHA-256 hash of a string\r\n *\r\n * @async\r\n * @param {string} string\r\n * @returns {Promise<string>}\r\n */\r\nasync function hashFromString(string) {\r\n   const hash = await crypto.subtle.digest(\"SHA-256\", new TextEncoder().encode(string));\r\n   let astr = btoa(String.fromCharCode(...new Uint8Array(hash)));\r\n\r\n   // Remove padding equal characters\r\n   astr = astr.replace(/=+$/, \"\");\r\n\r\n   // Replace non-url compatible chars with base64 standard chars\r\n   astr = astr.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\r\n\r\n   return astr;\r\n}\r\n\r\nfunction btoaUrl(input) {\r\n   // Encode using the standard Javascript function\r\n   let astr = btoa(input);\r\n\r\n   // Replace non-url compatible chars with base64 standard chars\r\n   astr = astr.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\r\n\r\n   return astr;\r\n}\r\n\r\nfunction encodeFormAttributes(formAttributes) {\r\n   var formBody = [];\r\n   for (var property in formAttributes) {\r\n      var encodedKey = encodeURIComponent(property);\r\n      var encodedValue = encodeURIComponent(formAttributes[property]);\r\n      formBody.push(encodedKey + \"=\" + encodedValue);\r\n   }\r\n   formBody = formBody.join(\"&\");\r\n   return formBody;\r\n}\r\n\r\nwindow.MHR.register(\r\n   \"EBSIRedirect\",\r\n   class extends window.MHR.AbstractPage {\r\n      constructor(id) {\r\n         console.log(\"EBSIRedirect constructor\");\r\n         super(id);\r\n      }\r\n\r\n      async enter(qrData) {\r\n         mylog(qrData);\r\n         const urlParams = new URL(qrData).searchParams;\r\n\r\n         const redirect_uri = decodeURIComponent(urlParams.get(\"redirect_uri\"));\r\n         console.log(\"redirect_uri\", redirect_uri);\r\n         const client_id = decodeURIComponent(urlParams.get(\"client_id\"));\r\n         const state = decodeURIComponent(urlParams.get(\"state\"));\r\n         const nonce = decodeURIComponent(urlParams.get(\"nonce\"));\r\n\r\n         // Get my DID\r\n         const myDID = await window.MHR.storage.didFirst();\r\n\r\n         const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce);\r\n         console.log(\"IDToken\", IDToken);\r\n\r\n         var formAttributes = {\r\n            id_token: IDToken,\r\n            state: state,\r\n         };\r\n\r\n         var formBody = [];\r\n         for (var property in formAttributes) {\r\n            var encodedKey = encodeURIComponent(property);\r\n            var encodedValue = encodeURIComponent(formAttributes[property]);\r\n            formBody.push(encodedKey + \"=\" + encodedValue);\r\n         }\r\n         formBody = formBody.join(\"&\");\r\n         console.log(\"Body\", formBody);\r\n\r\n         let resp = await fetch(redirect_uri, {\r\n            method: \"POST\",\r\n            redirect: \"follow\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n               \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n            },\r\n            body: formBody,\r\n            mode: \"cors\",\r\n         });\r\n\r\n         if (resp.ok && resp.redirected) {\r\n            // The reply is the complete JWT\r\n            debugger;\r\n            console.log(resp.url);\r\n            location = resp.url;\r\n            return;\r\n         } else {\r\n            throw new Error(resp.statusText);\r\n         }\r\n      }\r\n   }\r\n);\r\n\r\n/**\r\n * generateDIDKeyProof creates a JWT which is used as a proof that the creator (the signer of the JWT) controls the\r\n * private key associated to the did:key (which is essentially the public key).\r\n * This concrete proof is specialised for OIDC4VCI flows, as indicated by the 'typ' field in the header.\r\n *\r\n * @async\r\n * @param {{did: string, privateKey: JsonWebKey, publicKey: JsonWebKey}} subjectDID The did and associated private key object for the Subject\r\n * @param {string} issuerID The identifier for the Issuer in the OID4VCI flow. Do not confuse with the issuer of the JWT,\r\n * which should be the person who will be receiving the Verifiable Credential.\r\n * @param {string} nonce The challenge received from the Issuer that we have to sign as a proof of possession\r\n * @returns {Promise<string>} The JWT in compact string form\r\n */\r\nasync function generateDIDKeyProof(subjectDID, issuerID, nonce) {\r\n   const subjectKid = subjectDID.did;\r\n\r\n   // Create the headers of the JWT\r\n   var jwtHeaders = {\r\n      typ: \"openid4vci-proof+jwt\",\r\n      alg: \"ES256\",\r\n      kid: subjectKid,\r\n   };\r\n\r\n   // It expires in one day (it could be much shorter in many flows)\r\n   const iat = Math.floor(Date.now() / 1000) - 2;\r\n   const exp = iat + 86500;\r\n\r\n   // The issuer of the JWT is the person who will receive the Verifiable Credential at the end of the OID4VCI flow.\r\n   // This is why the 'iss' claim is set to the did:key of the Subject.\r\n   // The JWT is intended for the entity that is issuing the Verifiable Credential in the OID4VCI flow. This is the\r\n   // reason why the 'aud' claim is set to the did (whatever did method is used) of the VC Issuer.\r\n   var jwtPayload = {\r\n      // iss: subjectDID.did,\r\n      aud: issuerID,\r\n      iat: iat,\r\n      exp: exp,\r\n      nonce: nonce,\r\n   };\r\n\r\n   // The JWT is signed with the private key associated to the did:key of the creator of the JWT.\r\n   const jwt = await signJWT(jwtHeaders, jwtPayload, subjectDID.privateKey);\r\n\r\n   return jwt;\r\n}\r\n\r\nasync function generateEBSIIDToken(subjectDID, issuerID, state, nonce) {\r\n   const keyStr = subjectDID.did.replace(\"did:key:\", \"\");\r\n   const subjectKid = subjectDID.did + \"#\" + keyStr;\r\n\r\n   // Create the request proof for authenticating this request\r\n   var jwtHeaders = {\r\n      typ: \"JWT\",\r\n      alg: \"ES256\",\r\n      kid: subjectKid,\r\n   };\r\n\r\n   const iat = Math.floor(Date.now() / 1000) - 2;\r\n   const exp = iat + 86500;\r\n\r\n   var jwtPayload = {\r\n      iss: subjectDID.did,\r\n      sub: subjectDID.did,\r\n      aud: issuerID,\r\n      iat: iat,\r\n      exp: exp,\r\n      state: state,\r\n      nonce: nonce,\r\n   };\r\n\r\n   const jwt = await signJWT(jwtHeaders, jwtPayload, subjectDID.privateKey);\r\n   return jwt;\r\n}\r\n\r\nwindow.MHR.register(\r\n   \"EBSIRedirectCode\",\r\n   class extends window.MHR.AbstractPage {\r\n      constructor(id) {\r\n         console.log(\"EBSIRedirectCode constructor\");\r\n         super(id);\r\n      }\r\n\r\n      async enter(qrData) {\r\n         mylog(qrData);\r\n         const urlParams = new URL(qrData).searchParams;\r\n         debugger;\r\n\r\n         const code = decodeURIComponent(urlParams.get(\"code\"));\r\n         console.log(\"redirect_uri\", redirect_uri);\r\n\r\n         // Get my DID\r\n         const myDID = await window.MHR.storage.didFirst();\r\n\r\n         const IDToken = await generateEBSIIDToken(myDID, client_id, state, nonce);\r\n         console.log(\"IDToken\", IDToken);\r\n         debugger;\r\n\r\n         var formAttributes = {\r\n            id_token: IDToken,\r\n            state: state,\r\n         };\r\n\r\n         var formBody = [];\r\n         for (var property in formAttributes) {\r\n            var encodedKey = encodeURIComponent(property);\r\n            var encodedValue = encodeURIComponent(formAttributes[property]);\r\n            formBody.push(encodedKey + \"=\" + encodedValue);\r\n         }\r\n         formBody = formBody.join(\"&\");\r\n         console.log(\"Body\", formBody);\r\n\r\n         let response = await fetch(redirect_uri, {\r\n            method: \"POST\",\r\n            cache: \"no-cache\",\r\n            headers: {\r\n               \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n            },\r\n            body: formBody,\r\n            mode: \"cors\",\r\n         });\r\n\r\n         if (response.ok) {\r\n            // The reply is the complete JWT\r\n            return;\r\n         } else {\r\n            throw new Error(response.statusText);\r\n         }\r\n      }\r\n   }\r\n);\r\n\r\nasync function doGETText(serverURL) {\r\n   var response = await fetch(serverURL, {\r\n      cache: \"no-cache\",\r\n      mode: \"cors\",\r\n   });\r\n   if (response.ok) {\r\n      var responseText = await response.text();\r\n      mylog(`doFetchText ${serverURL}:`, responseText);\r\n      return responseText;\r\n   } else {\r\n      const errormsg = `doFetchText ${serverURL}: ${response.status}`;\r\n      myerror(errormsg);\r\n      throw new Error(errormsg);\r\n   }\r\n}\r\n\r\nasync function doGETJSON(serverURL) {\r\n   if (!serverURL) {\r\n      throw new Error(\"No serverURL\");\r\n   }\r\n\r\n   var response;\r\n   if (proxyIssuer) {\r\n      let forwardBody = {\r\n         method: \"GET\",\r\n         url: serverURL,\r\n      };\r\n      response = await fetch(viaServer, {\r\n         method: \"POST\",\r\n         body: JSON.stringify(forwardBody),\r\n         headers: {\r\n            \"Content-Type\": \"application/json\",\r\n         },\r\n         cache: \"no-cache\",\r\n      });\r\n   } else {\r\n      response = await fetch(serverURL);\r\n   }\r\n\r\n   if (response.ok) {\r\n      var responseJSON = await response.json();\r\n      mylog(`doFetchJSON ${serverURL}:`, responseJSON);\r\n      return responseJSON;\r\n   } else {\r\n      const errormsg = `doFetchJSON ${serverURL}: ${response.status}`;\r\n      myerror(errormsg);\r\n      throw new Error(errormsg);\r\n   }\r\n}\r\n\r\nasync function doPOST(serverURL, body, mimetype = \"application/json\", authorization) {\r\n   debugger;\r\n   if (!serverURL) {\r\n      throw new Error(\"No serverURL\");\r\n   }\r\n\r\n   var response;\r\n   if (proxyIssuer) {\r\n      let forwardBody = {\r\n         method: \"POST\",\r\n         url: serverURL,\r\n         mimetype: mimetype,\r\n         body: body,\r\n      };\r\n      if (authorization) {\r\n         forwardBody[\"authorization\"] = authorization;\r\n      }\r\n      response = await fetch(viaServer, {\r\n         method: \"POST\",\r\n         body: JSON.stringify(forwardBody),\r\n         headers: {\r\n            \"Content-Type\": \"application/json\",\r\n         },\r\n         cache: \"no-cache\",\r\n      });\r\n   } else {\r\n      response = await fetch(serverURL, {\r\n         method: \"POST\",\r\n         body: JSON.stringify(body),\r\n         headers: {\r\n            \"Content-Type\": mimetype,\r\n         },\r\n         cache: \"no-cache\",\r\n      });\r\n   }\r\n   console.log(response);\r\n\r\n   if (response.ok) {\r\n      var responseJSON = await response.json();\r\n      console.log(responseJSON);\r\n      mylog(`doPOST ${serverURL}:`, responseJSON);\r\n      return responseJSON;\r\n   } else {\r\n      const errormsg = `doPOST ${serverURL}: ${response.status}`;\r\n      myerror(errormsg, body);\r\n      throw new Error(errormsg);\r\n   }\r\n}\r\n\r\nwindow.MHR.register(\r\n   \"VCAcceptedPage\",\r\n   class extends window.MHR.AbstractPage {\r\n      constructor(id) {\r\n         super(id);\r\n      }\r\n\r\n      async enter() {\r\n         let html = this.html;\r\n\r\n         var theHtml = html`\r\n            <ion-card>\r\n               <ion-card-header>\r\n                  <ion-card-title>Credential offer accepted</ion-card-title>\r\n               </ion-card-header>\r\n\r\n               <ion-card-content>\r\n                  <div class=\"ion-margin-top\">\r\n                     <ion-text class=\"ion-margin-top\"\r\n                        >You have authorised the issuance of the Verifiable Credential.</ion-text\r\n                     >\r\n                  </div>\r\n               </ion-card-content>\r\n\r\n               <div class=\"ion-margin-start ion-margin-bottom\">\r\n                  <ion-button\r\n                     @click=${() => {\r\n                        window.MHR.cleanReload();\r\n                     }}\r\n                  >\r\n                     <ion-icon slot=\"start\" name=\"home\"></ion-icon>\r\n                     ${T(\"Home\")}\r\n                  </ion-button>\r\n               </div>\r\n            </ion-card>\r\n         `;\r\n\r\n         this.render(theHtml, false);\r\n      }\r\n   }\r\n);\r\n"],
  "mappings": "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",
  "names": ["vc", "credCard", "div", "redirect_uri", "client_id", "state", "nonce", "redirect_uri", "client_id", "state", "nonce"]
}
