{
  "version": 3,
  "sources": ["../../front/node_modules/uhtml/esm/utils.js", "../../front/node_modules/uhtml/esm/literals.js", "../../front/node_modules/uhtml/esm/render/hole.js", "../../front/node_modules/udomdiff/esm/index.js", "../../front/node_modules/domconstants/esm/constants.js", "../../front/node_modules/custom-function/esm/factory.js", "../../front/node_modules/uhtml/esm/range.js", "../../front/node_modules/uhtml/esm/persistent-fragment.js", "../../front/node_modules/uhtml/esm/handler.js", "../../front/node_modules/uhtml/esm/creator.js", "../../front/node_modules/domconstants/esm/re.js", "../../front/node_modules/@webreflection/uparser/esm/index.js", "../../front/node_modules/uhtml/esm/create-content.js", "../../front/node_modules/uhtml/esm/parser.js", "../../front/node_modules/uhtml/esm/rabbit.js", "../../front/node_modules/uhtml/esm/index.js"],
  "sourcesContent": ["const { isArray } = Array;\nconst { getPrototypeOf, getOwnPropertyDescriptor } = Object;\n\nexport { isArray };\n\nexport const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nexport const empty = [];\n\nexport const newRange = () => document.createRange();\n\n/**\n * Set the `key` `value` pair to the *Map* or *WeakMap* and returns the `value`\n * @template T\n * @param {Map | WeakMap} map\n * @param {any} key\n * @param {T} value\n * @returns {T}\n */\nexport const set = (map, key, value) => {\n  map.set(key, value);\n  return value;\n};\n\n/**\n * Return a descriptor, if any, for the referenced *Element*\n * @param {Element} ref\n * @param {string} prop\n * @returns \n */\nexport const gPD = (ref, prop) => {\n  let desc;\n  do { desc = getOwnPropertyDescriptor(ref, prop); }\n  while(!desc && (ref = getPrototypeOf(ref)));\n  return desc;\n};\n\n/* c8 ignore start */\n/**\n * @param {DocumentFragment} content\n * @param {number[]} path\n * @returns {Element}\n */\nexport const find = (content, path) => path.reduceRight(childNodesIndex, content);\nconst childNodesIndex = (node, i) => node.childNodes[i];\n/* c8 ignore stop */\n", "import { empty } from './utils.js';\n\n/** @typedef {import(\"./persistent-fragment.js\").PersistentFragment} PersistentFragment */\n/** @typedef {import(\"./rabbit.js\").Hole} Hole */\n\n/** @typedef {unknown} Value */\n/** @typedef {Node | Element | PersistentFragment} Target */\n/** @typedef {null | undefined | string | number | boolean | Node | Element | PersistentFragment} DOMValue */\n/** @typedef {Hole | Node} ArrayValue */\n\nexport const abc = (a, b, c) => ({ a, b, c });\n\nexport const bc = (b, c) => ({ b, c });\n\n/**\n * @typedef {Object} Detail\n * @property {any} v the current value of the interpolation / hole\n * @property {function} u the callback to update the value\n * @property {Node} t the target comment node or element\n * @property {string | null | Node} n the attribute name, if any, or `null`\n * @property {Cache | ArrayValue[] | null} c the cache value for this detail\n */\n\n/**\n * @returns {Detail}\n */\nexport const detail = (u, t, n, c) => ({ v: empty, u, t, n, c });\n\n/**\n * @typedef {Object} Entry\n * @property {number[]} a the path to retrieve the node\n * @property {function} b the update function\n * @property {string | null} c the attribute name, if any, or `null`\n */\n\n/**\n * @typedef {Object} Cache\n * @property {null | TemplateStringsArray} a the cached template\n * @property {null | Node | PersistentFragment} b the node returned when parsing the template\n * @property {Detail[]} c the list of updates to perform\n */\n\n/**\n * @returns {Cache}\n */\nexport const cache = () => abc(null, null, empty);\n", "import { cache } from '../literals.js';\nimport { set } from '../utils.js';\n\n/** @typedef {import(\"../rabbit.js\").Hole} Hole */\n\n/** @type {WeakMap<Element | DocumentFragment, import(\"../literals.js\").Cache>} */\nconst known = new WeakMap;\n\n/**\n * Render with smart updates within a generic container.\n * @template T\n * @param {T} where the DOM node where to render content\n * @param {(() => Hole) | Hole} what the hole to render\n * @returns\n */\nexport default (where, what) => {\n  const info = known.get(where) || set(known, where, cache());\n  const { b } = info;\n  if (b !== (typeof what === 'function' ? what() : what).toDOM(info))\n    where.replaceChildren(info.b.valueOf());\n  return where;\n};\n", "/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -0).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -0).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n", "export const ELEMENT_NODE = 1;\nexport const ATTRIBUTE_NODE = 2;\nexport const TEXT_NODE = 3;\nexport const COMMENT_NODE = 8;\nexport const DOCUMENT_NODE = 9;\nexport const DOCUMENT_TYPE_NODE = 10;\nexport const DOCUMENT_FRAGMENT_NODE = 11;\n", "const {setPrototypeOf} = Object;\n\n/**\n * @param {Function} Class any base class to extend without passing through it via super() call.\n * @returns {Function} an extensible class for the passed one.\n * @example\n *  // creating this very same module utility\n *  import custom from 'custom-function/factory';\n *  const CustomFunction = custom(Function);\n *  class MyFunction extends CustomFunction {}\n *  const mf = new MyFunction(() => {});\n */\nexport default Class => {\n  function Custom(target) {\n    return setPrototypeOf(target, new.target.prototype);\n  }\n  Custom.prototype = Class.prototype;\n  return Custom;\n};\n", "import { newRange } from './utils.js';\n\nlet range;\n/**\n * @param {Node | Element} firstChild\n * @param {Node | Element} lastChild\n * @param {boolean} preserve\n * @returns\n */\nexport default (firstChild, lastChild, preserve) => {\n  if (!range) range = newRange();\n  /* c8 ignore start */\n  if (preserve)\n    range.setStartAfter(firstChild);\n  else\n    range.setStartBefore(firstChild);\n  /* c8 ignore stop */\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n", "import { DOCUMENT_FRAGMENT_NODE } from 'domconstants/constants';\nimport custom from 'custom-function/factory';\nimport drop from './range.js';\nimport { empty } from './utils.js';\n\n/**\n * @param {PersistentFragment} fragment\n * @returns {Node | Element}\n */\nconst remove = ({firstChild, lastChild}, preserve) => drop(firstChild, lastChild, preserve);\n\nlet checkType = false;\n\n/**\n * @param {Node} node\n * @param {1 | 0 | -0 | -1} operation\n * @returns {Node}\n */\nexport const diffFragment = (node, operation) => (\n  checkType && node.nodeType === DOCUMENT_FRAGMENT_NODE ?\n    ((1 / operation) < 0 ?\n      (operation ? remove(node, true) : node.lastChild) :\n      (operation ? node.valueOf() : node.firstChild)) :\n    node\n);\n\nconst comment = value => document.createComment(value);\n\n/** @extends {DocumentFragment} */\nexport class PersistentFragment extends custom(DocumentFragment) {\n  #firstChild = comment('<>');\n  #lastChild = comment('</>');\n  #nodes = empty;\n  constructor(fragment) {\n    super(fragment);\n    this.replaceChildren(...[\n      this.#firstChild,\n      ...fragment.childNodes,\n      this.#lastChild,\n    ]);\n    checkType = true;\n  }\n  get firstChild() { return this.#firstChild; }\n  get lastChild() { return this.#lastChild; }\n  get parentNode() { return this.#firstChild.parentNode; }\n  remove() {\n    remove(this, false);\n  }\n  replaceWith(node) {\n    remove(this, true).replaceWith(node);\n  }\n  valueOf() {\n    const { parentNode } = this;\n    if (parentNode === this) {\n      if (this.#nodes === empty)\n        this.#nodes = [...this.childNodes];\n    }\n    else {\n      /* c8 ignore start */\n      // there are cases where a fragment might be just appended\n      // out of the box without valueOf() invoke (first render).\n      // When these are moved around and lose their parent and,\n      // such parent is not the fragment itself, it's possible there\n      // where changes or mutations in there to take care about.\n      // This is a render-only specific issue but it's tested and\n      // it's worth fixing to me to have more consistent fragments.\n      if (parentNode) {\n        let { firstChild, lastChild } = this;\n        this.#nodes = [firstChild];\n        while (firstChild !== lastChild)\n          this.#nodes.push((firstChild = firstChild.nextSibling));\n      }\n      /* c8 ignore stop */\n      this.replaceChildren(...this.#nodes);\n    }\n    return this;\n  }\n}\n", "import udomdiff from 'udomdiff';\nimport { empty, gPD, isArray, set } from './utils.js';\nimport { diffFragment } from './persistent-fragment.js';\nimport drop from './range.js';\n\nconst setAttribute = (element, name, value) =>\n  element.setAttribute(name, value);\n\n/**\n * @param {Element} element\n * @param {string} name\n * @returns {void}\n */\nexport const removeAttribute = (element, name) =>\n  element.removeAttribute(name);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const aria = (element, value) => {\n  for (const key in value) {\n    const $ = value[key];\n    const name = key === 'role' ? key : `aria-${key}`;\n    if ($ == null) removeAttribute(element, name);\n    else setAttribute(element, name, $);\n  }\n  return value;\n};\n\nlet listeners;\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const at = (element, value, name) => {\n  name = name.slice(1);\n  if (!listeners) listeners = new WeakMap;\n  const known = listeners.get(element) || set(listeners, element, {});\n  let current = known[name];\n  if (current && current[0]) element.removeEventListener(name, ...current);\n  current = isArray(value) ? value : [value, false];\n  known[name] = current;\n  if (current[0]) element.addEventListener(name, ...current);\n  return value;\n};\n\n/** @type {WeakMap<Node, Element | import(\"./persistent-fragment.js\").PersistentFragment>} */\nconst holes = new WeakMap;\n\n/**\n * @template T\n * @param {import(\"./literals.js\").Detail} detail\n * @param {T} value\n * @returns {T}\n */\nexport const hole = (detail, value) => {\n  const { t: node, n: hole } = detail;\n  let nullish = false;\n  switch (typeof value) {\n    case 'object':\n      if (value !== null) {\n        (hole || node).replaceWith((detail.n = value.valueOf()));\n        break;\n      }\n    case 'undefined':\n      nullish = true;\n    default:\n      node.data = nullish ? '' : value;\n      if (hole) {\n        detail.n = null;\n        hole.replaceWith(node);\n      }\n      break;\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const className = (element, value) => maybeDirect(\n  element, value, value == null ? 'class' : 'className'\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const data = (element, value) => {\n  const { dataset } = element;\n  for (const key in value) {\n    if (value[key] == null) delete dataset[key];\n    else dataset[key] = value[key];\n  }\n  return value;\n};\n\n/**\n * @template T\n * @param {Element | CSSStyleDeclaration} ref\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const direct = (ref, value, name) => (ref[name] = value);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const dot = (element, value, name) => direct(element, value, name.slice(1));\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const maybeDirect = (element, value, name) => (\n  value == null ?\n    (removeAttribute(element, name), value) :\n    direct(element, value, name)\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const ref = (element, value) => (\n  (typeof value === 'function' ?\n    value(element) : (value.current = element)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nconst regular = (element, value, name) => (\n  (value == null ?\n    removeAttribute(element, name) :\n    setAttribute(element, name, value)),\n  value\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const style = (element, value) => (\n  value == null ?\n    maybeDirect(element, value, 'style') :\n    direct(element.style, value, 'cssText')\n);\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @param {string} name\n * @returns {T}\n */\nexport const toggle = (element, value, name) => (\n  element.toggleAttribute(name.slice(1), value),\n  value\n);\n\n/**\n * @param {Node} node\n * @param {Node[]} value\n * @param {string} _\n * @param {Node[]} prev\n * @returns {Node[]}\n */\nexport const array = (node, value, prev) => {\n  // normal diff\n  const { length } = value;\n  node.data = `[${length}]`;\n  if (length)\n    return udomdiff(node.parentNode, prev, value, diffFragment, node);\n  /* c8 ignore start */\n  switch (prev.length) {\n    case 1:\n      prev[0].remove();\n    case 0:\n      break;\n    default:\n      drop(\n        diffFragment(prev[0], 0),\n        diffFragment(prev.at(-1), -0),\n        false\n      );\n      break;\n  }\n  /* c8 ignore stop */\n  return empty;\n};\n\nexport const attr = new Map([\n  ['aria', aria],\n  ['class', className],\n  ['data', data],\n  ['ref', ref],\n  ['style', style],\n]);\n\n/**\n * @param {HTMLElement | SVGElement} element\n * @param {string} name\n * @param {boolean} svg\n * @returns\n */\nexport const attribute = (element, name, svg) => {\n  switch (name[0]) {\n    case '.': return dot;\n    case '?': return toggle;\n    case '@': return at;\n    default: return (\n      svg || ('ownerSVGElement' in element) ?\n        (name === 'ref' ? ref : regular) :\n        (attr.get(name) || (\n          name in element ?\n            (name.startsWith('on') ?\n              direct :\n              (gPD(element, name)?.set ? maybeDirect : regular)\n            ) :\n            regular\n          )\n        )\n    );\n  }\n};\n\n/**\n * @template T\n * @param {Element} element\n * @param {T} value\n * @returns {T}\n */\nexport const text = (element, value) => (\n  (element.textContent = value == null ? '' : value),\n  value\n);\n", "import { PersistentFragment } from './persistent-fragment.js';\nimport { bc, detail } from './literals.js';\nimport { array, hole } from './handler.js';\nimport { empty, find } from './utils.js';\nimport { cache } from './literals.js';\n\n/** @param {(template: TemplateStringsArray, values: any[]) => import(\"./parser.js\").Resolved} parse */\nexport default parse => (\n  /**\n   * @param {TemplateStringsArray} template\n   * @param {any[]} values\n   * @returns {import(\"./literals.js\").Cache}\n   */\n  (template, values) => {\n    const { a: fragment, b: entries, c: direct } = parse(template, values);\n    const root = document.importNode(fragment, true);\n    /** @type {import(\"./literals.js\").Detail[]} */\n    let details = empty;\n    if (entries !== empty) {\n      details = [];\n      for (let current, prev, i = 0; i < entries.length; i++) {\n        const { a: path, b: update, c: name } = entries[i];\n        const node = path === prev ? current : (current = find(root, (prev = path)));\n        details[i] = detail(\n          update,\n          node,\n          name,\n          update === array ? [] : (update === hole ? cache() : null)\n        );\n      }\n    }\n    return bc(\n      direct ? root.firstChild : new PersistentFragment(root),\n      details,\n    );\n  }\n);\n", "export const TEXT_ELEMENTS = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\nexport const VOID_ELEMENTS = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\n", "import { VOID_ELEMENTS } from 'domconstants/re';\n\nconst elements = /<([a-zA-Z0-9]+[a-zA-Z0-9:._-]*)([^>]*?)(\\/?)>/g;\nconst attributes = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)\\x01/g;\nconst holes = /[\\x01\\x02]/g;\n\n// \\x01 Node.ELEMENT_NODE\n// \\x02 Node.ATTRIBUTE_NODE\n\n/**\n * Given a template, find holes as both nodes and attributes and\n * return a string with holes as either comment nodes or named attributes.\n * @param {string[]} template a template literal tag array\n * @param {string} prefix prefix to use per each comment/attribute\n * @param {boolean} xml enforces self-closing tags\n * @returns {string} X/HTML with prefixed comments or attributes\n */\nexport default (template, prefix, xml) => {\n  let i = 0;\n  return template\n    .join('\\x01')\n    .trim()\n    .replace(\n      elements,\n      (_, name, attrs, selfClosing) => `<${\n          name\n        }${\n          attrs.replace(attributes, '\\x02=$2$1').trimEnd()\n        }${\n          selfClosing ? (\n            (xml || VOID_ELEMENTS.test(name)) ? ' /' : `></${name}`\n          ) : ''\n        }>`\n    )\n    .replace(\n      holes,\n      hole => hole === '\\x01' ? `<!--${prefix + i++}-->` : (prefix + i++)\n    )\n  ;\n};\n", "import { SVG_NAMESPACE, newRange } from './utils.js';\n\nlet template = document.createElement('template'), svg, range;\n\n/**\n * @param {string} text\n * @param {boolean} xml\n * @returns {DocumentFragment}\n */\nexport default (text, xml) => {\n  if (xml) {\n    if (!svg) {\n      svg = document.createElementNS(SVG_NAMESPACE, 'svg');\n      range = newRange();\n      range.selectNodeContents(svg);\n    }\n    return range.createContextualFragment(text);\n  }\n  template.innerHTML = text;\n  const { content } = template;\n  template = template.cloneNode(false);\n  return content;\n};\n", "import { COMMENT_NODE, ELEMENT_NODE } from 'domconstants/constants';\nimport { TEXT_ELEMENTS } from 'domconstants/re';\nimport parser from '@webreflection/uparser';\n\nimport { empty, isArray, set } from './utils.js';\nimport { abc } from './literals.js';\n\nimport { array, attribute, hole, text, removeAttribute } from './handler.js';\nimport createContent from './create-content.js';\n\n/** @typedef {import(\"./literals.js\").Entry} Entry */\n\n/**\n * @typedef {Object} Resolved\n * @param {DocumentFragment} f content retrieved from the template\n * @param {Entry[]} e entries per each hole in the template\n * @param {boolean} d direct node to handle\n */\n\n/**\n * @param {Element} node\n * @returns {number[]}\n */\nconst createPath = node => {\n  const path = [];\n  let parentNode;\n  while ((parentNode = node.parentNode)) {\n    path.push(path.indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n  }\n  return path;\n};\n\nconst textNode = () => document.createTextNode('');\n\n/**\n * @param {TemplateStringsArray} template\n * @param {boolean} xml\n * @returns {Resolved}\n */\nconst resolve = (template, values, xml) => {\n  const content = createContent(parser(template, prefix, xml), xml);\n  const { length } = template;\n  let entries = empty;\n  if (length > 1) {\n    const replace = [];\n    const tw = document.createTreeWalker(content, 1 | 128);\n    let i = 0, search = `${prefix}${i++}`;\n    entries = [];\n    while (i < length) {\n      const node = tw.nextNode();\n      // these are holes or arrays\n      if (node.nodeType === COMMENT_NODE) {\n        if (node.data === search) {\n          // âš ï¸ once array, always array!\n          const update = isArray(values[i - 1]) ? array : hole;\n          if (update === hole) replace.push(node);\n          entries.push(abc(createPath(node), update, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n      else {\n        let path;\n        // these are attributes\n        while (node.hasAttribute(search)) {\n          if (!path) path = createPath(node);\n          const name = node.getAttribute(search);\n          entries.push(abc(path, attribute(node, name, xml), name));\n          removeAttribute(node, search);\n          search = `${prefix}${i++}`;\n        }\n        // these are special text-only nodes\n        if (\n          !xml &&\n          TEXT_ELEMENTS.test(node.localName) &&\n          node.textContent.trim() === `<!--${search}-->`\n        ) {\n          entries.push(abc(path || createPath(node), text, null));\n          search = `${prefix}${i++}`;\n        }\n      }\n    }\n    // can't replace holes on the fly or the tree walker fails\n    for (i = 0; i < replace.length; i++)\n      replace[i].replaceWith(textNode());\n  }\n\n  // need to decide if there should be a persistent fragment\n  const { childNodes } = content;\n  let { length: len } = childNodes;\n\n  // html`` or svg`` to signal an empty content\n  // these nodes can be passed directly as never mutated\n  if (len < 1) {\n    len = 1;\n    content.appendChild(textNode());\n  }\n  // html`${'b'}` or svg`${[]}` cases\n  else if (\n    len === 1 &&\n    // ignore html`static` or svg`static` because\n    // these nodes can be passed directly as never mutated\n    length !== 1 &&\n    childNodes[0].nodeType !== ELEMENT_NODE\n  ) {\n    // use a persistent fragment for these cases too\n    len = 0;\n  }\n\n  return set(cache, template, abc(content, entries, len === 1));\n};\n\n/** @type {WeakMap<TemplateStringsArray, Resolved>} */\nconst cache = new WeakMap;\nconst prefix = 'isÂµ';\n\n/**\n * @param {boolean} xml\n * @returns {(template: TemplateStringsArray, values: any[]) => Resolved}\n */\nexport default xml => (template, values) => cache.get(template) || resolve(template, values, xml);\n", "import { array, hole } from './handler.js';\nimport { cache } from './literals.js';\nimport create from './creator.js';\nimport parser from './parser.js';\n\nconst createHTML = create(parser(false));\nconst createSVG = create(parser(true));\n\n/**\n * @param {import(\"./literals.js\").Cache} info\n * @param {Hole} hole\n * @returns {Node}\n */\nconst unroll = (info, { s, t, v }) => {\n  if (info.a !== t) {\n    const { b, c } = (s ? createSVG : createHTML)(t, v);\n    info.a = t;\n    info.b = b;\n    info.c = c;\n  }\n  for (let { c } = info, i = 0; i < c.length; i++) {\n    const value = v[i];\n    const detail = c[i];\n    switch (detail.u) {\n      case array:\n        detail.v = array(\n          detail.t,\n          unrollValues(detail.c, value),\n          detail.v\n        );\n        break;\n      case hole:\n        const current = value instanceof Hole ?\n          unroll(detail.c || (detail.c = cache()), value) :\n          (detail.c = null, value)\n        ;\n        if (current !== detail.v)\n          detail.v = hole(detail, current);\n        break;\n      default:\n        if (value !== detail.v)\n          detail.v = detail.u(detail.t, value, detail.n, detail.v);\n        break;\n    }\n  }\n  return info.b;\n};\n\n/**\n * @param {Cache} cache\n * @param {any[]} values\n * @returns {number}\n */\nconst unrollValues = (stack, values) => {\n  let i = 0, { length } = values;\n  if (length < stack.length) stack.splice(length);\n  for (; i < length; i++) {\n    const value = values[i];\n    if (value instanceof Hole)\n      values[i] = unroll(stack[i] || (stack[i] = cache()), value);\n    else stack[i] = null;\n  }\n  return values;\n};\n\n/**\n * Holds all details needed to render the content on a render.\n * @constructor\n * @param {boolean} svg The content type.\n * @param {TemplateStringsArray} template The template literals used to the define the content.\n * @param {any[]} values Zero, one, or more interpolated values to render.\n */\nexport class Hole {\n  constructor(svg, template, values) {\n    this.s = svg;\n    this.t = template;\n    this.v = values;\n  }\n  toDOM(info = cache()) {\n    return unroll(info, this);\n  }\n};\n", "/*! (c) Andrea Giammarchi - MIT */\nimport { Hole } from './rabbit.js';\nimport { attr } from './handler.js';\n\nimport render from './render/hole.js';\n\n/** @typedef {import(\"./literals.js\").Value} Value */\n\nconst tag = svg => (template, ...values) => new Hole(svg, template, values);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render HTML content. */\nexport const html = tag(false);\n\n/** @type {(template: TemplateStringsArray, ...values:Value[]) => Hole} A tag to render SVG content. */\nexport const svg = tag(true);\n\nexport { Hole, render, attr };\n"],
  "mappings": "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",
  "names": ["ref", "known", "detail", "hole", "ref", "svg", "template", "direct", "esm_default", "template", "prefix", "hole", "range", "text", "template", "esm_default", "cache", "detail", "svg", "template", "svg", "template"]
}
