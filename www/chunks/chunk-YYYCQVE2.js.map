{
  "version": 3,
  "sources": ["../../front/src/components/jwt.js"],
  "sourcesContent": ["let log = window.MHR.log;\nlet myerror = window.MHR.storage.myerror;\nlet mylog = window.MHR.storage.mylog;\n\n/**\n * decodeJWT decodes the JWT without checking the signature.\n * But we will perform some important validations like expiration\n * @param {string}  jwt - The encoded JWT as a string with the three components separated by a dot.\n * @returns {{error: boolean, header: JSONObject, body: JSONObject, signature: string}}\n */\nexport function decodeUnsafeJWT(jwt) {\n   // We will decode the JWT without checking the signature\n   // But we will perform some important validations like expiration\n   mylog(\"in decodeJWT\");\n   mylog(jwt);\n\n   // This is the object that will be returned\n   let decoded = {\n      error: false,\n      header: undefined,\n      body: undefined,\n      signature: undefined,\n   };\n\n   let components = \"\";\n\n   // Check that jwt is a string\n   if (typeof jwt === \"string\" || jwt instanceof String) {\n      // Split the input in three components using the dots \".\" as separator\n      components = jwt.split(\".\");\n      mylog(\"components\", components);\n   } else {\n      decoded.error = \"Format error. Encoded credential is not a string\";\n      myerror(decoded.error);\n      return decoded;\n   }\n\n   if (components.length != 3) {\n      decoded.error = \"Malformed JWT, not enough components: \" + components.length;\n      myerror(decoded.error);\n      return decoded;\n   }\n\n   // Decode the header and the body into JSON objects\n   try {\n      decoded.header = JSON.parse(atobUrl(components[0]));\n      decoded.body = JSON.parse(atobUrl(components[1]));\n      mylog(decoded.body);\n      decoded.signature = components[2];\n   } catch (error) {\n      decoded.error = \"Error parsing header or body\";\n      myerror(decoded.error);\n      return decoded;\n   }\n\n   // Perform some consistency checks\n   if (!decoded.header) {\n      decoded.error = \"Field does not exist in JWT (header)\";\n      myerror(decoded.error);\n      return decoded;\n   }\n\n   return decoded;\n}\n\nfunction btoaUrl(input) {\n   // Encode using the standard Javascript function\n   let astr = btoa(input);\n\n   // Replace non-url compatible chars with base64 standard chars\n   astr = astr.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n\n   return astr;\n}\n\nfunction atobUrl(input) {\n   // Replace non-url compatible chars with base64 standard chars\n   input = input.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n   // Decode using the standard Javascript function\n   let bstr = decodeURIComponent(escape(atob(input)));\n\n   return bstr;\n}\n"],
  "mappings": ";AAAA,IAAI,MAAM,OAAO,IAAI;AACrB,IAAI,UAAU,OAAO,IAAI,QAAQ;AACjC,IAAI,QAAQ,OAAO,IAAI,QAAQ;AAQxB,SAAS,gBAAgB,KAAK;AAGlC,QAAM,cAAc;AACpB,QAAM,GAAG;AAGT,MAAI,UAAU;AAAA,IACX,OAAO;AAAA,IACP,QAAQ;AAAA,IACR,MAAM;AAAA,IACN,WAAW;AAAA,EACd;AAEA,MAAI,aAAa;AAGjB,MAAI,OAAO,QAAQ,YAAY,eAAe,QAAQ;AAEnD,iBAAa,IAAI,MAAM,GAAG;AAC1B,UAAM,cAAc,UAAU;AAAA,EACjC,OAAO;AACJ,YAAQ,QAAQ;AAChB,YAAQ,QAAQ,KAAK;AACrB,WAAO;AAAA,EACV;AAEA,MAAI,WAAW,UAAU,GAAG;AACzB,YAAQ,QAAQ,2CAA2C,WAAW;AACtE,YAAQ,QAAQ,KAAK;AACrB,WAAO;AAAA,EACV;AAGA,MAAI;AACD,YAAQ,SAAS,KAAK,MAAM,QAAQ,WAAW,CAAC,CAAC,CAAC;AAClD,YAAQ,OAAO,KAAK,MAAM,QAAQ,WAAW,CAAC,CAAC,CAAC;AAChD,UAAM,QAAQ,IAAI;AAClB,YAAQ,YAAY,WAAW,CAAC;AAAA,EACnC,SAAS,OAAO;AACb,YAAQ,QAAQ;AAChB,YAAQ,QAAQ,KAAK;AACrB,WAAO;AAAA,EACV;AAGA,MAAI,CAAC,QAAQ,QAAQ;AAClB,YAAQ,QAAQ;AAChB,YAAQ,QAAQ,KAAK;AACrB,WAAO;AAAA,EACV;AAEA,SAAO;AACV;AAYA,SAAS,QAAQ,OAAO;AAErB,UAAQ,MAAM,QAAQ,MAAM,GAAG,EAAE,QAAQ,MAAM,GAAG;AAGlD,MAAI,OAAO,mBAAmB,OAAO,KAAK,KAAK,CAAC,CAAC;AAEjD,SAAO;AACV;",
  "names": []
}
